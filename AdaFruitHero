#include <Adafruit_CircuitPlayground.h>

int score = 0, lastLeftButton, lastRightButton, scoreThresh = 600;
const uint8_t spU[] PROGMEM = {0xA1,0x9F,0x9C,0x94,0x72,0x26,0x8D,0x76,0x07,0x55,0x90,0x78,0x3C,0xEB,0x59,0x9D,0xA2,0x87,0x60,0x76,0xDA,0x72,0x8B,0x53,0x36,0xA5,0x64,0x2D,0x7B,0x6E,0xB5,0xFA,0x24,0xDC,0x32,0xB1,0x73,0x1F,0xFA,0x1C,0x16,0xAB,0xC6,0xCA,0xE0,0xB5,0xDF,0xCD,0xA1,0xD4,0x78,0x1B,0xB6,0x53,0x97,0x74,0xA7,0x21,0xBC,0xE4,0xFF,0x01};
const uint8_t spFAIL[] PROGMEM = {0x04,0x98,0x3E,0x8D,0x03,0x1C,0xD0,0x80,0x07,0x4A,0xBF,0x54,0x9B,0x3A,0x79,0x9C,0xCD,0xAA,0x9B,0x0F,0x31,0x8F,0x37,0xB7,0xBE,0xCD,0x6A,0x47,0x2A,0x66,0xB3,0xB7,0xB3,0xDB,0x6B,0x5F,0xC7,0x56,0x44,0x58,0x8E,0x76,0xAA,0x7B,0xD8,0x33,0xB9,0x32,0xD7,0x3C,0xF9,0x0C,0x67,0xD4,0x13,0x9E,0x98,0xC7,0x5F,0xEE,0x49,0x7C,0xAA,0x8D,0xF3,0xF9,0xF7,0xFF,0x01};
uint8_t spPASS[] PROGMEM = {0x0A,0xC8,0x33,0x83,0x03,0xA3,0xEC,0x55,0x2D,0xD4,0x12,0xAF,0xAA,0x04,0xC9,0xD4,0x0E,0x7D,0xAA,0x16,0x4A,0x33,0x65,0xCE,0xAD,0x6F,0x7D,0x9A,0x9A,0xDC,0xDB,0x62,0xEE,0x6D,0x6E,0x73,0xC6,0x12,0xDD,0x5B,0x6B,0xEE,0x5D,0xF6,0x3A,0xCE,0xAA,0xD2,0x26,0xED,0x75,0xBB,0x9B,0x4D,0x6D,0xF1,0x25,0xFD,0x77,0x7F,0xEF,0xD2,0xCE,0x9D,0x46,0x00,0x4B,0x17,0x2B,0xE0,0x8F,0x52,0x0B,0x68,0x40,0x02,0x1C,0x90,0xC0,0xFF,0x03};
enum GameState { Home, InProgress, End };
GameState currentState = Home;
enum SongName { HotCross, Twinkle, LittleLamb};
SongName currentSong = HotCross;

bool leftFlag = false, rightFlag = false,endStart = false;

void setup() {
  Serial.begin(9600);
  CircuitPlayground.begin();
  attachInterrupt(digitalPinToInterrupt(4), leftButton, RISING);
  attachInterrupt(digitalPinToInterrupt(5), rightButton, RISING);
  Serial.println("Press a button to begin.");
}

struct Song {
  int delay;
  int frequency;
  bool useSecondStrip;
};

//All Song Arrays Generated by GPT 4
//{delay,pitch,strip 1?}
Song HotCrossBuns[] = {
  {500, 262, false},
  {500, 294, true},
  {500, 330, false},
  {750, 262, true},
  {500, 294, false},
  {500, 330, true},
  {500, 330, false},
  {250, 330, true},
  {250, 294, false},
  {750, 262, true},
  {250, 330, true},
  {250, 294, false},
  {750, 262, true}
};

Song TwinkleTwinkle[] = {
  // "Twinkle, twinkle, little star,"
    {250, 261.63, false},  // C
    {250, 261.63, true},   // C
    {250, 392.00, false},  // G
    {250, 392.00, true},   // G
    {250, 440.00, false},  // A
    {250, 440.00, true},   // A
    {250, 392.00, false},  // G

    // "How I wonder what you are!"
    {250, 349.23, true},   // F
    {250, 349.23, false},  // F
    {250, 329.63, true},   // E
    {250, 329.63, false},  // E
    {250, 293.66, true},   // D
    {250, 293.66, false},  // D
    {250, 261.63, true},   // C

};

Song MaryHadALittleLamb[] = {
    // "Mary had a little lamb,"
    {400, 329.63, false}, // E
    {400, 293.66, true},  // D
    {400, 261.63, false}, // C
    {400, 293.66, true},  // D
    {400, 329.63, false}, // E
    {400, 329.63, true},  // E
    {400, 329.63, false}, // E

    // "Little lamb, little lamb,"
    {400, 293.66, true},  // D
    {400, 293.66, false}, // D
    {400, 293.66, true},  // D

    // "Mary had a little lamb,"
    {400, 329.63, false}, // E
    {400, 329.63, true},  // E
    {400, 329.63, false}, // E

    // "Its fleece was white as snow."
    {400, 293.66, true},  // D
    {400, 293.66, false}, // D
    {400, 329.63, true},  // E
    {400, 293.66, false}, // D
    {400, 261.63, true},  // C
};

void loop() {
  switch (currentState) {
    //This case takes user input from buttons and selects a song. 
    case Home:
      if (leftFlag || rightFlag) {
        delay(200);
        if (leftFlag && rightFlag) {
          Serial.print("Game Starting In: ");
          leftFlag = false;
          rightFlag = false;
          changeState(InProgress);
        } else {
          if (leftFlag) {
            currentSong = static_cast<SongName>((currentSong - 1 +3) % 3);
            leftFlag = false;
            delay(200);
          }
          if (rightFlag) {
            currentSong = static_cast<SongName>((currentSong + 1) % 3);
            rightFlag = false;
            delay(200);
          }
          displaySongs();
          Serial.println();   
        }
      }
      break;
    case InProgress:
      //Countdown from 5
      for(int i = 5; i > 0; i--) {
        Serial.print(i); Serial.print(" ");
        for (int j = 0; j < 10; j++) {
          CircuitPlayground.setPixelColor(j,0,255,0);
        }
        delay(500);
        CircuitPlayground.clearPixels();
        delay(500);
      }
      //This switch handles array traversal for all three songs, every case has same functionality with different arrays
      switch(currentSong) {
        case HotCross:
          for (int i = 0; i < sizeof(HotCrossBuns) / sizeof(HotCrossBuns[0]); i++) {
            int startLed, endLed, step;
            if (HotCrossBuns[i].useSecondStrip) {
              // Count backwards on the second strip
              startLed = 9;
              endLed = 5;
              step = -1; 
            } else {
              // Count forwards on the first strip
              startLed = 0;
              endLed = 4;
              step = 1; 
            }
            // Animate LEDs from start to end
            for (int led = startLed; step == 1 ? led <= endLed : led >= endLed; led += step) {
              CircuitPlayground.setPixelColor(led, 255, 0, 0);
              delay(HotCrossBuns[i].delay / (abs(endLed - startLed) + 1)); // Divide total delay by number of LEDs
              CircuitPlayground.clearPixels();
            }
          //Note Start Time
          int noteStartTime = millis();
          CircuitPlayground.playTone(HotCrossBuns[i].frequency, HotCrossBuns[i].delay); // Play the tone for the duration of the note
          //Note End Time
          int noteEndTime = millis();

          //Lines 163-176 are for scoring
          bool isLeftNote = !HotCrossBuns[i].useSecondStrip;
          if (isLeftNote) {
            if (lastLeftButton >= noteStartTime - scoreThresh && lastLeftButton <= noteEndTime + scoreThresh) {
              score++;
            } else {
              score--;
            }
          } else {
            if (lastRightButton >= noteStartTime - scoreThresh && lastRightButton <= noteEndTime + scoreThresh) {
              score++;
            } else {
              score--;
            }
          }

          leftFlag = false;
          rightFlag = false;
          }
          break;

        case Twinkle:
          for (int i = 0; i < sizeof(TwinkleTwinkle) / sizeof(TwinkleTwinkle[0]); i++) {
            int startLed, endLed, step;
            if (TwinkleTwinkle[i].useSecondStrip) {
              startLed = 9;
              endLed = 5;
              step = -1; // Count backwards on the second strip
            } else {
              startLed = 0;
              endLed = 4;
              step = 1; // Count forwards on the first strip
            }
            // Animate LEDs from start to end
            for (int led = startLed; step == 1 ? led <= endLed : led >= endLed; led += step) {
              CircuitPlayground.setPixelColor(led, 0, 0, 255); // Display blue color for "Enter Sandman"
              delay(TwinkleTwinkle[i].delay / (abs(endLed - startLed) + 1)); // Divide total delay by number of LEDs
              CircuitPlayground.clearPixels();
            }
            // Play tone when hitting the last LED
            int noteStartTime = millis();
            CircuitPlayground.playTone(TwinkleTwinkle[i].frequency, TwinkleTwinkle[i].delay); // Play the tone for the duration of the note
            int noteEndTime = millis();
            bool isLeftNote = !TwinkleTwinkle[i].useSecondStrip;
            if (isLeftNote) {
              if (lastLeftButton >= noteStartTime - scoreThresh && lastLeftButton <= noteEndTime + scoreThresh) {
                score++;
              } else {
                score--;
              }
            } else {
              if (lastRightButton >= noteStartTime - scoreThresh && lastRightButton <= noteEndTime + scoreThresh) {
                score++;
              } else {
                score--;
              }
            }

            leftFlag = false;
            rightFlag = false;
          }
          break;
        case LittleLamb:
          for (int i = 0; i < sizeof(MaryHadALittleLamb) / sizeof(MaryHadALittleLamb[0]); i++) {
            int startLed, endLed, step;
            if (MaryHadALittleLamb[i].useSecondStrip) {
              startLed = 9;
              endLed = 5;
              step = -1; // Count backwards on the second strip
            } else {
              startLed = 0;
              endLed = 4;
              step = 1; // Count forwards on the first strip
            }
            // Animate LEDs from start to end
            for (int led = startLed; step == 1 ? led <= endLed : led >= endLed; led += step) {
              CircuitPlayground.setPixelColor(led, 0, 0, 255); // Display blue color for "Enter Sandman"
              delay(MaryHadALittleLamb[i].delay / (abs(endLed - startLed) + 1)); // Divide total delay by number of LEDs
              CircuitPlayground.clearPixels();
            }
            int noteStartTime = millis();
            CircuitPlayground.playTone(MaryHadALittleLamb[i].frequency, MaryHadALittleLamb[i].delay); // Play the tone for the duration of the note
            int noteEndTime = millis();
            bool isLeftNote = !MaryHadALittleLamb[i].useSecondStrip;
            if (isLeftNote) {
              if (lastLeftButton >= noteStartTime - scoreThresh && lastLeftButton <= noteEndTime + scoreThresh) {
                score++;
              } else {
                score--;
              }
            } else {
              if (lastRightButton >= noteStartTime - scoreThresh && lastRightButton <= noteEndTime + scoreThresh) {
                score++;
              } else {
                score--;
              }
            }

            leftFlag = false;
            rightFlag = false;
          }
          break;
        break;
      }
    changeState(End);  
    break;
    case End:
      //this statement ensures this is only ran once
      if (!endStart) {
        delay(100);
        Serial.println("====================================================");
        Serial.print("Score: "); Serial.println(score);
        if (score <= 0){
          CircuitPlayground.speaker.say(spU);
          delay(200);
          CircuitPlayground.speaker.say(spFAIL);
        }else{
          CircuitPlayground.speaker.say(spU);
          delay(200);
          CircuitPlayground.speaker.say(spPASS);
        }
        Serial.println("Play Again?");
        endStart = true;
      }
      if (leftFlag && rightFlag){
          leftFlag = false;
          rightFlag = false;
          for(int i = 5; i > 0; i--) {
            //Serial.print(i); Serial.print(" ");
            for (int j = 0; j < 10; j++) {
              CircuitPlayground.setPixelColor(j,0,255,0);
            }
            delay(100);
            CircuitPlayground.clearPixels();
            delay(100);
          }
          changeState(Home);
      }
      break;
  }
}

//This function displays the song selection in the serial monitor
void displaySongs() {
  for (int i = HotCross; i <= LittleLamb; i++) {
    if (i == currentSong) {
      Serial.print("[");
    }
    switch(i) {
      case HotCross: Serial.print("Hot Cross Buns (easy)"); break;
      case Twinkle: Serial.print("Twinkle Twinkle Little Star (hard)"); break;
      case LittleLamb: Serial.print("Mary Had A Little lamb (medium)"); break;  // Assuming you add the song
    }
    if (i == currentSong) {
      Serial.print("]");
    }
    Serial.print(", ");
  }
}

//This function handles state changes
void changeState(GameState state) {
  switch(state) {
    case Home:
      endStart = false;
      score = 0;
      currentState = Home;
      break;
    case InProgress:
      currentState = InProgress;
      break;
    case End:
      currentState = End;
      break;
  }
}

void leftButton() {
  leftFlag = true;
  lastLeftButton = millis();
}

void rightButton() {
  rightFlag = true;
  lastRightButton = millis();
}

